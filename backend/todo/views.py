# todo/views.py
from typing import Optional

from celery.result import AsyncResult
from celery.states import SUCCESS as CELERY_SUCCESS
from django.core.exceptions import BadRequest
from django.http import JsonResponse
from rest_framework import status, viewsets  # add this
from rest_framework.views import APIView

from backend import celery

from .models import TaskGeneratedTodo, Todo  # add this
from .serializers import (
    TaskGeneratedResolvedTodoSerializer,
    TaskGeneratedTodoSerializer,
    TodoSerializer,
)


class TodoView(viewsets.ModelViewSet):  # add this
    serializer_class = TodoSerializer  # add this
    queryset = Todo.objects.all()  # add this


class GeneratedTodoView(viewsets.ModelViewSet):  # add this
    serializer_class = TaskGeneratedTodoSerializer  # add this
    queryset = TaskGeneratedTodo.objects.all()  # add this


# @method_decorator(csrf.csrf_exempt, name='dispatch')
"""
Simulate that TODOs are generated by a celery task.

The client issues a POST request to this view, which starts a
celery task to generate TODOs, returning a task `task_id`.

The client then issues GET requests to this view with the
task ID, plus the last sequence number received. The view
responds with the TODOs generated since the last one.

When the task is complete, the GET request will return an
`end` parameter, that the client can use to know when to stop.

If an error occurred during the task, an `error` field is
returned. If there are TODOs generated before the error since the
last time, they are returned and the HTTP status is OK. If there
are no TODOs generated since the last time, in case of an error
the HTTP status is Internal Server Error.
"""


class TodosStream(APIView):
    serializer_class = TodoSerializer  # add this

    def post(self, *args):
        task_id = celery.generate_todos_task.delay().id
        last = -1
        return self.do_get(task_id, last, end=None, task_error=None)

    @staticmethod
    def do_get(task_id: str, last: int, end: Optional[int], task_error: any):
        if last is None:
            raise BadRequest("`last` is required")
        task = AsyncResult(task_id)
        task_state = task.state

        if end is None:
            if task_state == CELERY_SUCCESS:
                result = task.get()
                end = result["end"]
            elif task.ready():
                try:
                    task_error = task.result["error"]
                except (KeyError, AttributeError):
                    task_error = {"message": "Unknown error generating TODOs"}

        todos = TaskGeneratedTodo.objects.filter(
            task_id=task_id, sequence_number__gt=last
        ).order_by("sequence_number")

        if task_error is not None:
            if todos.exists():
                end = todos.last().sequence_number
            else:
                return JsonResponse(
                    {
                        "task_id": task_id,
                        "todos": [],
                        "last": last,
                        "end": end,
                        "error": task_error,
                    },
                    status=status.HTTP_500_INTERNAL_SERVER_ERROR,
                )

        response = {
            "task_id": task_id,
            "todos": TaskGeneratedResolvedTodoSerializer(todos, many=True).data,
            "last": last,
            "end": end,
        }

        if task_error is not None:
            response["error"] = task_error

        return JsonResponse(response)

    def get(self, request):
        task_id = request.GET.get("task_id")
        if task_id is None or type(task_id) is not str:
            raise BadRequest("`task_id` is required to be a string")
        last = request.GET.get("last")
        # TODO: start using serializers for query parameters
        if last is not None:
            try:
                last = int(last)
            except ValueError:
                raise BadRequest("`last` is required to be an integer")
        else:
            raise BadRequest("`last` is required to be an integer")
        end = request.GET.get("end")
        if end is not None:
            try:
                end = int(end)
            except ValueError:
                raise BadRequest("`end` is required to be an integer")
            if last >= end:
                raise BadRequest("`last` must be less than `end`")

        error = request.GET.get("error")
        return self.do_get(task_id, last, end, task_error=error)
